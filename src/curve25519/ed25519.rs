//! Implemented according to [IETF RFC 8032](https://datatracker.ietf.org/doc/html/rfc8032).

use core::convert::TryInto;

use crate::sha2::{sha512, Sha512};

use super::arith_mod_l::{
	add_num_mod_l,
	mul_num_mod_l,
	num_mod_l_from_32_bytes,
	num_mod_l_from_64_bytes,
	num_mod_l_to_bytes,
};
use super::conditional_swap;
use super::num::Num;

#[derive(Copy, Clone)]
struct Point {
	x: Num,
	y: Num,
	z: Num,
	t: Num,
}

const ED25519_D: Num = Num {
	segments: [
		0x34dca135978a3,
		0x1a8283b156ebd,
		0x5e7a26001c029,
		0x739c663a03cbb,
		0x52036cee2b6ff,
	],
};

const SQRT_MINUS_1: Num = Num {
	segments: [
		0x61b274a0ea0b0,
		0x0d5a5fc8f189d,
		0x7ef5e9cbd0c60,
		0x78595a6804c9e,
		0x2b8324804fc1d,
	],
};

const BASE_POINT: Point = Point {
	x: Num {
		segments: [
			0x62d608f25d51a,
			0x412a4b4f6592a,
			0x75b7171a4b31d,
			0x1ff60527118fe,
			0x216936d3cd6e5,
		],
	},
	y: Num {
		segments: [
			0x6666666666658,
			0x4cccccccccccc,
			0x1999999999999,
			0x3333333333333,
			0x6666666666666,
		],
	},
	z: Num::ONE,
	t: Num {
		segments: [
			0x68ab3a5b7dda3,
			0x00eea2a5eadbb,
			0x2af8df483c27e,
			0x332b375274732,
			0x67875f0fd78b7,
		],
	},
};

fn compress(point: Point) -> [u8; 32] {
	let x = point.x / point.z;
	let mut y = point.y / point.z;

	y.full_modular_reduction();

	let mut out = y.to_bytes();
	let sign = x.segments[0] & 0x01 != 0;

	if sign {
		out[31] |= 0x80;
	}

	out
}

// does not work in constant time, should never be used on secret data
fn decompress(mut compressed: [u8; 32]) -> Option<Point> {
	let x_sign = compressed[31] & 0x80 != 0;
	compressed[31] &= 0x7f;

	// verify
	if !verify_less_than_p(&compressed) {
		return None;
	}

	let y = Num::from_bytes(compressed);
	let y_squared = y * y;

	let mut u = y_squared - Num::ONE;
	let v = ED25519_D * y_squared + Num::ONE;

	let v_cubed = v * v * v;
	let v_to_the_7 = v_cubed * v_cubed * v;

	// exponentiate u v^7 to (p - 5) / 8

	let factor = u * v_to_the_7;

	let mut accum = Num::ONE;

	for _ in 0 .. 250 {
		accum *= accum;
		accum *= factor;
	}

	accum *= accum;
	accum *= accum;
	accum *= factor;

	let mut x = u * v_cubed * accum;
	let mut vxx = v * x * x;

	let mut neg_u = -u;

	// we're gonna be comparing these
	// so we canonicalize them by performing a full modular reduction
	u.full_modular_reduction();
	neg_u.full_modular_reduction();
	vxx.full_modular_reduction();

	if vxx.segments == neg_u.segments {
		x *= SQRT_MINUS_1;
	} else if vxx.segments != u.segments {
		return None;
	}

	if x.segments == [0, 0, 0, 0, 0] && x_sign {
		return None;
	}

	if (x.segments[0] & 0x01 != 0) ^ x_sign {
		x = -x;
	}

	Some(Point {
		x,
		y,
		z: Num::ONE,
		t: x * y,
	})
}

// helper function for decompress, not constant-time
fn verify_less_than_p(compressed: &[u8; 32]) -> bool {
	// in order for the compressed point to be >= p (2 ** 255 - 19),
	// the highest byte must be 0x7f, the lowest byte must be more than
	// 256 - 19 = 0xed, and all other bytes must be 0xff

	if compressed[0] < 0xed {
		return true;
	}

	for i in 1 .. 30 {
		if compressed[i] != 0xff {
			return true;
		}
	}

	if compressed[31] != 0x7f {
		return true;
	}

	return false;
}

// TODO: you can probably rewrite the above function to me more like this one
// helper function for verifying signarutes, not constant-time
fn verify_less_than_l(value: &[u8; 32]) -> bool {
	let limit = [
		0xed, 0xd3, 0xf5, 0x5c, 0x1a, 0x63, 0x12, 0x58,
		0xd6, 0x9c, 0xf7, 0xa2, 0xde, 0xf9, 0xde, 0x14,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10,
	];

	for i in (0 .. 32).rev() {
		if value[i] > limit[i] {
			return false;
		}

		if value[i] < limit[i] {
			return true;
		}
	}

	return false;
}

const NEUTRAL_POINT: Point = Point {
	x: Num::ZERO,
	y: Num::ONE,
	z: Num::ONE,
	t: Num::ZERO,
};

fn ed25519_mult(scalar: &[u8], num_bits: usize, point: Point) -> Point {
	let mut swapped = 0;

	let mut point_active = NEUTRAL_POINT;
	let mut point_inactive = point;

	let mut accum = NEUTRAL_POINT;

	for current_bit in (0 .. num_bits).rev() {
		let current_bit = (scalar[current_bit / 8] >> (current_bit % 8)) & 0x01;
		conditional_swap_points(
			swapped ^ current_bit,
			&mut point_active,
			&mut point_inactive,
		);
		swapped = current_bit;

		accum = point_double(accum);
		accum = point_add(accum, point_active);
	}

	accum
}

fn conditional_swap_points(swap: u8, point_a: &mut Point, point_b: &mut Point) {
	conditional_swap(swap, &mut point_a.x, &mut point_b.x);
	conditional_swap(swap, &mut point_a.y, &mut point_b.y);
	conditional_swap(swap, &mut point_a.z, &mut point_b.z);
	conditional_swap(swap, &mut point_a.t, &mut point_b.t);
}

// these functions are out of the RFC, including most of the variable naming

fn point_add(point_a: Point, point_b: Point) -> Point {
	let Point {x: x_a, y: y_a, z: z_a, t: t_a} = point_a;
	let Point {x: x_b, y: y_b, z: z_b, t: t_b} = point_b;

	let a = (y_a - x_a) * (y_b - x_b);
	let b = (y_a + x_a) * (y_b + x_b);
	let c_half = t_a * ED25519_D * t_b;
	let c = c_half + c_half;
	let d_half = z_a * z_b;
	let d = d_half + d_half;
	let e = b - a;
	let f = d - c;
	let g = d + c;
	let h = b + a;

	Point {x: e * f, y: g * h, t: e * h, z: f * g}
}

fn point_double(point: Point) -> Point {
	let Point {x, y, z, ..} = point;

	let a = x * x;
	let b = y * y;
	let c_half = z * z;
	let c = c_half + c_half;
	let h = a + b;
	let e_sub = x + y;
	let e = h - e_sub * e_sub;
	let g = a - b;
	let f = c + g;

	Point {x: e * f, y: g * h, t: e * h, z: f * g}
}

fn clamp_and_mult(buffer: &mut [u8; 32]) -> [u8; 32] {
	buffer[0] &= 0xf8;
	buffer[31] &= 0x7f;
	buffer[31] |= 0x40;

	let pub_key_point = ed25519_mult(buffer, 255, BASE_POINT);

	compress(pub_key_point)
}

/// Returns your public key given your `priv_key`.
pub fn ed25519_derive_pub_key(priv_key: [u8; 32]) -> [u8; 32] {
	let digest: [u8; 64] = sha512(&priv_key);
	let mut secret_scalar: [u8; 32] = digest[0 .. 32].try_into().unwrap();
	clamp_and_mult(&mut secret_scalar)
}

fn ed25519_sign_core(
	priv_key: [u8; 32],
	dom2_prefix: &[u8],
	context: &[u8],
	message: &[u8],
) -> [u8; 64] {
	let digest: [u8; 64] = sha512(&priv_key);
	let mut secret_scalar: [u8; 32] = digest[0 .. 32].try_into().unwrap();
	let pub_key = clamp_and_mult(&mut secret_scalar);

	let prefix: &[u8; 32] = &digest[32 .. 64].try_into().unwrap();

	let mut r_hasher = Sha512::new();
	r_hasher.add_bytes(dom2_prefix);
	r_hasher.add_bytes(context);
	r_hasher.add_bytes(prefix);
	r_hasher.add_bytes(message);

	let little_r = r_hasher.out();
	let little_r_num = num_mod_l_from_64_bytes(&little_r);
	let little_r_bytes = num_mod_l_to_bytes(little_r_num);
	let big_r = ed25519_mult(&little_r_bytes, 253, BASE_POINT);
	let big_r = compress(big_r);

	let mut k_hasher = Sha512::new();
	k_hasher.add_bytes(dom2_prefix);
	k_hasher.add_bytes(context);
	k_hasher.add_bytes(&big_r);
	k_hasher.add_bytes(&pub_key);
	k_hasher.add_bytes(message);
	let k = k_hasher.out();
	let k = num_mod_l_from_64_bytes(&k);

	let little_s_num = num_mod_l_from_32_bytes(&secret_scalar);
	let big_s = add_num_mod_l(little_r_num, mul_num_mod_l(k, little_s_num));
	let big_s = num_mod_l_to_bytes(big_s);

	let mut out = [0; 64];

	out[0 .. 32].copy_from_slice(&big_r);
	out[32 .. 64].copy_from_slice(&big_s);

	out
}

// core algorithm for verifying ed25519 signatures
// not constant-time since it doesn't involve secret data
fn ed25519_verify_core(
	pub_key: [u8; 32],
	signature: [u8; 64],
	dom2_prefix: &[u8],
	context: &[u8],
	message: &[u8],
) -> bool {
	let pub_key_point = match decompress(pub_key) {
		Some(val) => val,
		None => return false,
	};

	let big_r_bytes = signature[0 .. 32].try_into().unwrap();
	let big_r = match decompress(big_r_bytes) {
		Some(val) => val,
		None => return false,
	};

	let big_s: [u8; 32] = signature[32 .. 64].try_into().unwrap();

	if !verify_less_than_l(&big_s) {
		return false;
	}

	let mut hasher = Sha512::new();
	hasher.add_bytes(dom2_prefix);
	hasher.add_bytes(context);
	hasher.add_bytes(&big_r_bytes);
	hasher.add_bytes(&pub_key);
	hasher.add_bytes(message);

	let k = hasher.out();
	let k = num_mod_l_to_bytes(num_mod_l_from_64_bytes(&k));

	let left_side = ed25519_mult(&big_s, 253, BASE_POINT);
	let right_side = point_add(
		big_r,
		ed25519_mult(&k, 253, pub_key_point),
	);

	compress(left_side) == compress(right_side)
}

/// Creates an Ed25519 digital signature, given a `priv_key` and `message`.
/// This signature can be verified by anyone, given your public key,
/// the the original `message`, and the signature.
pub fn ed25519_sign(priv_key: [u8; 32], message: &[u8]) -> [u8; 64] {
	ed25519_sign_core(priv_key, &[], &[], message)
}

/// Verifies an Ed25519 digital signature. This implementation is *not*
/// constant-time, as it does not involve secret data.
pub fn ed25519_verify(
	pub_key: [u8; 32],
	message: &[u8],
	signature: [u8; 64],
) -> bool {
	ed25519_verify_core(pub_key, signature, &[], &[], message)
}

/// Creates an Ed25519ctx digital signature, given a `priv_key`, a `message`,
/// and a `context`. The `context` is a byte slice of less than 256 bytes
/// that describes the protocol or application the signature is for. The
/// `context` should not be empty, nor should it depend on the content of
/// the `message`.
pub fn ed25519ctx_sign(
	priv_key: [u8; 32],
	message: &[u8],
	context: &[u8],
) -> [u8; 64] {
	assert!(context.len() <= 255);

	let mut dom2_prefix = [0; 34];
	dom2_prefix[0 .. 32].copy_from_slice(b"SigEd25519 no Ed25519 collisions");
	dom2_prefix[32] = 0x00;
	dom2_prefix[33] = context.len().try_into().unwrap();

	ed25519_sign_core(priv_key, &dom2_prefix, context, message)
}

/// Verifies an Ed25519ctx digital signature. This implementation is *not*
/// constant-time, as it does not involve secret data.
pub fn ed25519ctx_verify(
	pub_key: [u8; 32],
	message: &[u8],
	context: &[u8],
	signature: [u8; 64],
) -> bool {
	assert!(context.len() <= 255);

	let mut dom2_prefix = [0; 34];
	dom2_prefix[0 .. 32].copy_from_slice(b"SigEd25519 no Ed25519 collisions");
	dom2_prefix[32] = 0x00;
	dom2_prefix[33] = context.len().try_into().unwrap();

	ed25519_verify_core(pub_key, signature, &dom2_prefix, context, message)
}

/// Creates an Ed25519ph digital signature, given a `priv_key`, a `message`,
/// and a `context`. Unlike Ed25519ctx, the `context` here is optional, and
/// should be left empty in the default case. Ed25519ph signs a SHA-512 hash of
/// the input `message`, and is therefore vulnerable if weaknesses in SHA-512
/// are discovered. For this reason, it's not recommended to use this, unless
/// for some reason, Ed25519 is not suitable for your use-case.
pub fn ed25519ph_sign(
	priv_key: [u8; 32],
	message: &[u8],
	context: &[u8],
) -> [u8; 64] {
	assert!(context.len() <= 255);

	let mut dom2_prefix = [0; 34];
	dom2_prefix[0 .. 32].copy_from_slice(b"SigEd25519 no Ed25519 collisions");
	dom2_prefix[32] = 0x01;
	dom2_prefix[33] = context.len().try_into().unwrap();

	let message = sha512(&message);

	ed25519_sign_core(priv_key, &dom2_prefix, context, &message)
}

/// Verifies an Ed25519ph digital signature. This implementation is *not*
/// constant-time, as it does not involve secret data.
pub fn ed25519ph_verify(
	pub_key: [u8; 32],
	message: &[u8],
	context: &[u8],
	signature: [u8; 64],
) -> bool {
	assert!(context.len() <= 255);

	let mut dom2_prefix = [0; 34];
	dom2_prefix[0 .. 32].copy_from_slice(b"SigEd25519 no Ed25519 collisions");
	dom2_prefix[32] = 0x01;
	dom2_prefix[33] = context.len().try_into().unwrap();

	let message = sha512(&message);

	ed25519_verify_core(pub_key, signature, &dom2_prefix, context, &message)
}

#[test]
fn test_compress_and_decompress_base_point() {
	let compressed = compress(BASE_POINT);
	let decompressed = decompress(compressed).unwrap();

	let to_array = |point: Point| [point.x, point.y, point.z, point.t];

	let base_point = to_array(BASE_POINT);
	let decompressed = to_array(decompressed);

	for i in 0 .. 4 {
		assert!(decompressed[i].segments == base_point[i].segments)
	}
}

#[test]
fn ed25519_test_vector_1() {
	let priv_key = [
		0x9d, 0x61, 0xb1, 0x9d, 0xef, 0xfd, 0x5a, 0x60,
		0xba, 0x84, 0x4a, 0xf4, 0x92, 0xec, 0x2c, 0xc4,
		0x44, 0x49, 0xc5, 0x69, 0x7b, 0x32, 0x69, 0x19,
		0x70, 0x3b, 0xac, 0x03, 0x1c, 0xae, 0x7f, 0x60,
	];

	let pub_key = [
		0xd7, 0x5a, 0x98, 0x01, 0x82, 0xb1, 0x0a, 0xb7,
		0xd5, 0x4b, 0xfe, 0xd3, 0xc9, 0x64, 0x07, 0x3a,
		0x0e, 0xe1, 0x72, 0xf3, 0xda, 0xa6, 0x23, 0x25,
		0xaf, 0x02, 0x1a, 0x68, 0xf7, 0x07, 0x51, 0x1a,
	];

	assert_eq!(ed25519_derive_pub_key(priv_key), pub_key);

	let message = &[];

	let signature = [
		0xe5, 0x56, 0x43, 0x00, 0xc3, 0x60, 0xac, 0x72,
		0x90, 0x86, 0xe2, 0xcc, 0x80, 0x6e, 0x82, 0x8a,
		0x84, 0x87, 0x7f, 0x1e, 0xb8, 0xe5, 0xd9, 0x74,
		0xd8, 0x73, 0xe0, 0x65, 0x22, 0x49, 0x01, 0x55,
		0x5f, 0xb8, 0x82, 0x15, 0x90, 0xa3, 0x3b, 0xac,
		0xc6, 0x1e, 0x39, 0x70, 0x1c, 0xf9, 0xb4, 0x6b,
		0xd2, 0x5b, 0xf5, 0xf0, 0x59, 0x5b, 0xbe, 0x24,
		0x65, 0x51, 0x41, 0x43, 0x8e, 0x7a, 0x10, 0x0b,
	];

	assert_eq!(ed25519_sign(priv_key, message), signature);

	assert!(ed25519_verify(pub_key, message, signature));
}

#[test]
fn ed25519_test_vector_2() {
	let priv_key = [
		0x4c, 0xcd, 0x08, 0x9b, 0x28, 0xff, 0x96, 0xda,
		0x9d, 0xb6, 0xc3, 0x46, 0xec, 0x11, 0x4e, 0x0f,
		0x5b, 0x8a, 0x31, 0x9f, 0x35, 0xab, 0xa6, 0x24,
		0xda, 0x8c, 0xf6, 0xed, 0x4f, 0xb8, 0xa6, 0xfb,
	];

	let pub_key = [
		0x3d, 0x40, 0x17, 0xc3, 0xe8, 0x43, 0x89, 0x5a,
		0x92, 0xb7, 0x0a, 0xa7, 0x4d, 0x1b, 0x7e, 0xbc,
		0x9c, 0x98, 0x2c, 0xcf, 0x2e, 0xc4, 0x96, 0x8c,
		0xc0, 0xcd, 0x55, 0xf1, 0x2a, 0xf4, 0x66, 0x0c,
	];

	assert_eq!(ed25519_derive_pub_key(priv_key), pub_key);

	let message = &[0x72];

	let signature = [
		0x92, 0xa0, 0x09, 0xa9, 0xf0, 0xd4, 0xca, 0xb8,
		0x72, 0x0e, 0x82, 0x0b, 0x5f, 0x64, 0x25, 0x40,
		0xa2, 0xb2, 0x7b, 0x54, 0x16, 0x50, 0x3f, 0x8f,
		0xb3, 0x76, 0x22, 0x23, 0xeb, 0xdb, 0x69, 0xda,
		0x08, 0x5a, 0xc1, 0xe4, 0x3e, 0x15, 0x99, 0x6e,
		0x45, 0x8f, 0x36, 0x13, 0xd0, 0xf1, 0x1d, 0x8c,
		0x38, 0x7b, 0x2e, 0xae, 0xb4, 0x30, 0x2a, 0xee,
		0xb0, 0x0d, 0x29, 0x16, 0x12, 0xbb, 0x0c, 0x00,
	];

	assert_eq!(ed25519_sign(priv_key, message), signature);

	assert!(ed25519_verify(pub_key, message, signature));
}

#[test]
fn ed25519_test_vector_3() {
	let priv_key = [
		0xc5, 0xaa, 0x8d, 0xf4, 0x3f, 0x9f, 0x83, 0x7b,
		0xed, 0xb7, 0x44, 0x2f, 0x31, 0xdc, 0xb7, 0xb1,
		0x66, 0xd3, 0x85, 0x35, 0x07, 0x6f, 0x09, 0x4b,
		0x85, 0xce, 0x3a, 0x2e, 0x0b, 0x44, 0x58, 0xf7,
	];

	let pub_key = [
		0xfc, 0x51, 0xcd, 0x8e, 0x62, 0x18, 0xa1, 0xa3,
		0x8d, 0xa4, 0x7e, 0xd0, 0x02, 0x30, 0xf0, 0x58,
		0x08, 0x16, 0xed, 0x13, 0xba, 0x33, 0x03, 0xac,
		0x5d, 0xeb, 0x91, 0x15, 0x48, 0x90, 0x80, 0x25,
	];

	assert_eq!(ed25519_derive_pub_key(priv_key), pub_key);

	let message = &[0xaf, 0x82];

	let signature = [
		0x62, 0x91, 0xd6, 0x57, 0xde, 0xec, 0x24, 0x02,
		0x48, 0x27, 0xe6, 0x9c, 0x3a, 0xbe, 0x01, 0xa3,
		0x0c, 0xe5, 0x48, 0xa2, 0x84, 0x74, 0x3a, 0x44,
		0x5e, 0x36, 0x80, 0xd7, 0xdb, 0x5a, 0xc3, 0xac,
		0x18, 0xff, 0x9b, 0x53, 0x8d, 0x16, 0xf2, 0x90,
		0xae, 0x67, 0xf7, 0x60, 0x98, 0x4d, 0xc6, 0x59,
		0x4a, 0x7c, 0x15, 0xe9, 0x71, 0x6e, 0xd2, 0x8d,
		0xc0, 0x27, 0xbe, 0xce, 0xea, 0x1e, 0xc4, 0x0a,
	];

	assert_eq!(ed25519_sign(priv_key, message), signature);

	assert!(ed25519_verify(pub_key, message, signature));
}

#[test]
fn ed25519_test_vector_1024() {
	let priv_key = [
		0xf5, 0xe5, 0x76, 0x7c, 0xf1, 0x53, 0x31, 0x95,
		0x17, 0x63, 0x0f, 0x22, 0x68, 0x76, 0xb8, 0x6c,
		0x81, 0x60, 0xcc, 0x58, 0x3b, 0xc0, 0x13, 0x74,
		0x4c, 0x6b, 0xf2, 0x55, 0xf5, 0xcc, 0x0e, 0xe5,
	];

	let pub_key = [
		0x27, 0x81, 0x17, 0xfc, 0x14, 0x4c, 0x72, 0x34,
		0x0f, 0x67, 0xd0, 0xf2, 0x31, 0x6e, 0x83, 0x86,
		0xce, 0xff, 0xbf, 0x2b, 0x24, 0x28, 0xc9, 0xc5,
		0x1f, 0xef, 0x7c, 0x59, 0x7f, 0x1d, 0x42, 0x6e,
	];

	assert_eq!(ed25519_derive_pub_key(priv_key), pub_key);

	let message = &[
		0x08, 0xb8, 0xb2, 0xb7, 0x33, 0x42, 0x42, 0x43,
		0x76, 0x0f, 0xe4, 0x26, 0xa4, 0xb5, 0x49, 0x08,
		0x63, 0x21, 0x10, 0xa6, 0x6c, 0x2f, 0x65, 0x91,
		0xea, 0xbd, 0x33, 0x45, 0xe3, 0xe4, 0xeb, 0x98,
		0xfa, 0x6e, 0x26, 0x4b, 0xf0, 0x9e, 0xfe, 0x12,
		0xee, 0x50, 0xf8, 0xf5, 0x4e, 0x9f, 0x77, 0xb1,
		0xe3, 0x55, 0xf6, 0xc5, 0x05, 0x44, 0xe2, 0x3f,
		0xb1, 0x43, 0x3d, 0xdf, 0x73, 0xbe, 0x84, 0xd8,
		0x79, 0xde, 0x7c, 0x00, 0x46, 0xdc, 0x49, 0x96,
		0xd9, 0xe7, 0x73, 0xf4, 0xbc, 0x9e, 0xfe, 0x57,
		0x38, 0x82, 0x9a, 0xdb, 0x26, 0xc8, 0x1b, 0x37,
		0xc9, 0x3a, 0x1b, 0x27, 0x0b, 0x20, 0x32, 0x9d,
		0x65, 0x86, 0x75, 0xfc, 0x6e, 0xa5, 0x34, 0xe0,
		0x81, 0x0a, 0x44, 0x32, 0x82, 0x6b, 0xf5, 0x8c,
		0x94, 0x1e, 0xfb, 0x65, 0xd5, 0x7a, 0x33, 0x8b,
		0xbd, 0x2e, 0x26, 0x64, 0x0f, 0x89, 0xff, 0xbc,
		0x1a, 0x85, 0x8e, 0xfc, 0xb8, 0x55, 0x0e, 0xe3,
		0xa5, 0xe1, 0x99, 0x8b, 0xd1, 0x77, 0xe9, 0x3a,
		0x73, 0x63, 0xc3, 0x44, 0xfe, 0x6b, 0x19, 0x9e,
		0xe5, 0xd0, 0x2e, 0x82, 0xd5, 0x22, 0xc4, 0xfe,
		0xba, 0x15, 0x45, 0x2f, 0x80, 0x28, 0x8a, 0x82,
		0x1a, 0x57, 0x91, 0x16, 0xec, 0x6d, 0xad, 0x2b,
		0x3b, 0x31, 0x0d, 0xa9, 0x03, 0x40, 0x1a, 0xa6,
		0x21, 0x00, 0xab, 0x5d, 0x1a, 0x36, 0x55, 0x3e,
		0x06, 0x20, 0x3b, 0x33, 0x89, 0x0c, 0xc9, 0xb8,
		0x32, 0xf7, 0x9e, 0xf8, 0x05, 0x60, 0xcc, 0xb9,
		0xa3, 0x9c, 0xe7, 0x67, 0x96, 0x7e, 0xd6, 0x28,
		0xc6, 0xad, 0x57, 0x3c, 0xb1, 0x16, 0xdb, 0xef,
		0xef, 0xd7, 0x54, 0x99, 0xda, 0x96, 0xbd, 0x68,
		0xa8, 0xa9, 0x7b, 0x92, 0x8a, 0x8b, 0xbc, 0x10,
		0x3b, 0x66, 0x21, 0xfc, 0xde, 0x2b, 0xec, 0xa1,
		0x23, 0x1d, 0x20, 0x6b, 0xe6, 0xcd, 0x9e, 0xc7,
		0xaf, 0xf6, 0xf6, 0xc9, 0x4f, 0xcd, 0x72, 0x04,
		0xed, 0x34, 0x55, 0xc6, 0x8c, 0x83, 0xf4, 0xa4,
		0x1d, 0xa4, 0xaf, 0x2b, 0x74, 0xef, 0x5c, 0x53,
		0xf1, 0xd8, 0xac, 0x70, 0xbd, 0xcb, 0x7e, 0xd1,
		0x85, 0xce, 0x81, 0xbd, 0x84, 0x35, 0x9d, 0x44,
		0x25, 0x4d, 0x95, 0x62, 0x9e, 0x98, 0x55, 0xa9,
		0x4a, 0x7c, 0x19, 0x58, 0xd1, 0xf8, 0xad, 0xa5,
		0xd0, 0x53, 0x2e, 0xd8, 0xa5, 0xaa, 0x3f, 0xb2,
		0xd1, 0x7b, 0xa7, 0x0e, 0xb6, 0x24, 0x8e, 0x59,
		0x4e, 0x1a, 0x22, 0x97, 0xac, 0xbb, 0xb3, 0x9d,
		0x50, 0x2f, 0x1a, 0x8c, 0x6e, 0xb6, 0xf1, 0xce,
		0x22, 0xb3, 0xde, 0x1a, 0x1f, 0x40, 0xcc, 0x24,
		0x55, 0x41, 0x19, 0xa8, 0x31, 0xa9, 0xaa, 0xd6,
		0x07, 0x9c, 0xad, 0x88, 0x42, 0x5d, 0xe6, 0xbd,
		0xe1, 0xa9, 0x18, 0x7e, 0xbb, 0x60, 0x92, 0xcf,
		0x67, 0xbf, 0x2b, 0x13, 0xfd, 0x65, 0xf2, 0x70,
		0x88, 0xd7, 0x8b, 0x7e, 0x88, 0x3c, 0x87, 0x59,
		0xd2, 0xc4, 0xf5, 0xc6, 0x5a, 0xdb, 0x75, 0x53,
		0x87, 0x8a, 0xd5, 0x75, 0xf9, 0xfa, 0xd8, 0x78,
		0xe8, 0x0a, 0x0c, 0x9b, 0xa6, 0x3b, 0xcb, 0xcc,
		0x27, 0x32, 0xe6, 0x94, 0x85, 0xbb, 0xc9, 0xc9,
		0x0b, 0xfb, 0xd6, 0x24, 0x81, 0xd9, 0x08, 0x9b,
		0xec, 0xcf, 0x80, 0xcf, 0xe2, 0xdf, 0x16, 0xa2,
		0xcf, 0x65, 0xbd, 0x92, 0xdd, 0x59, 0x7b, 0x07,
		0x07, 0xe0, 0x91, 0x7a, 0xf4, 0x8b, 0xbb, 0x75,
		0xfe, 0xd4, 0x13, 0xd2, 0x38, 0xf5, 0x55, 0x5a,
		0x7a, 0x56, 0x9d, 0x80, 0xc3, 0x41, 0x4a, 0x8d,
		0x08, 0x59, 0xdc, 0x65, 0xa4, 0x61, 0x28, 0xba,
		0xb2, 0x7a, 0xf8, 0x7a, 0x71, 0x31, 0x4f, 0x31,
		0x8c, 0x78, 0x2b, 0x23, 0xeb, 0xfe, 0x80, 0x8b,
		0x82, 0xb0, 0xce, 0x26, 0x40, 0x1d, 0x2e, 0x22,
		0xf0, 0x4d, 0x83, 0xd1, 0x25, 0x5d, 0xc5, 0x1a,
		0xdd, 0xd3, 0xb7, 0x5a, 0x2b, 0x1a, 0xe0, 0x78,
		0x45, 0x04, 0xdf, 0x54, 0x3a, 0xf8, 0x96, 0x9b,
		0xe3, 0xea, 0x70, 0x82, 0xff, 0x7f, 0xc9, 0x88,
		0x8c, 0x14, 0x4d, 0xa2, 0xaf, 0x58, 0x42, 0x9e,
		0xc9, 0x60, 0x31, 0xdb, 0xca, 0xd3, 0xda, 0xd9,
		0xaf, 0x0d, 0xcb, 0xaa, 0xaf, 0x26, 0x8c, 0xb8,
		0xfc, 0xff, 0xea, 0xd9, 0x4f, 0x3c, 0x7c, 0xa4,
		0x95, 0xe0, 0x56, 0xa9, 0xb4, 0x7a, 0xcd, 0xb7,
		0x51, 0xfb, 0x73, 0xe6, 0x66, 0xc6, 0xc6, 0x55,
		0xad, 0xe8, 0x29, 0x72, 0x97, 0xd0, 0x7a, 0xd1,
		0xba, 0x5e, 0x43, 0xf1, 0xbc, 0xa3, 0x23, 0x01,
		0x65, 0x13, 0x39, 0xe2, 0x29, 0x04, 0xcc, 0x8c,
		0x42, 0xf5, 0x8c, 0x30, 0xc0, 0x4a, 0xaf, 0xdb,
		0x03, 0x8d, 0xda, 0x08, 0x47, 0xdd, 0x98, 0x8d,
		0xcd, 0xa6, 0xf3, 0xbf, 0xd1, 0x5c, 0x4b, 0x4c,
		0x45, 0x25, 0x00, 0x4a, 0xa0, 0x6e, 0xef, 0xf8,
		0xca, 0x61, 0x78, 0x3a, 0xac, 0xec, 0x57, 0xfb,
		0x3d, 0x1f, 0x92, 0xb0, 0xfe, 0x2f, 0xd1, 0xa8,
		0x5f, 0x67, 0x24, 0x51, 0x7b, 0x65, 0xe6, 0x14,
		0xad, 0x68, 0x08, 0xd6, 0xf6, 0xee, 0x34, 0xdf,
		0xf7, 0x31, 0x0f, 0xdc, 0x82, 0xae, 0xbf, 0xd9,
		0x04, 0xb0, 0x1e, 0x1d, 0xc5, 0x4b, 0x29, 0x27,
		0x09, 0x4b, 0x2d, 0xb6, 0x8d, 0x6f, 0x90, 0x3b,
		0x68, 0x40, 0x1a, 0xde, 0xbf, 0x5a, 0x7e, 0x08,
		0xd7, 0x8f, 0xf4, 0xef, 0x5d, 0x63, 0x65, 0x3a,
		0x65, 0x04, 0x0c, 0xf9, 0xbf, 0xd4, 0xac, 0xa7,
		0x98, 0x4a, 0x74, 0xd3, 0x71, 0x45, 0x98, 0x67,
		0x80, 0xfc, 0x0b, 0x16, 0xac, 0x45, 0x16, 0x49,
		0xde, 0x61, 0x88, 0xa7, 0xdb, 0xdf, 0x19, 0x1f,
		0x64, 0xb5, 0xfc, 0x5e, 0x2a, 0xb4, 0x7b, 0x57,
		0xf7, 0xf7, 0x27, 0x6c, 0xd4, 0x19, 0xc1, 0x7a,
		0x3c, 0xa8, 0xe1, 0xb9, 0x39, 0xae, 0x49, 0xe4,
		0x88, 0xac, 0xba, 0x6b, 0x96, 0x56, 0x10, 0xb5,
		0x48, 0x01, 0x09, 0xc8, 0xb1, 0x7b, 0x80, 0xe1,
		0xb7, 0xb7, 0x50, 0xdf, 0xc7, 0x59, 0x8d, 0x5d,
		0x50, 0x11, 0xfd, 0x2d, 0xcc, 0x56, 0x00, 0xa3,
		0x2e, 0xf5, 0xb5, 0x2a, 0x1e, 0xcc, 0x82, 0x0e,
		0x30, 0x8a, 0xa3, 0x42, 0x72, 0x1a, 0xac, 0x09,
		0x43, 0xbf, 0x66, 0x86, 0xb6, 0x4b, 0x25, 0x79,
		0x37, 0x65, 0x04, 0xcc, 0xc4, 0x93, 0xd9, 0x7e,
		0x6a, 0xed, 0x3f, 0xb0, 0xf9, 0xcd, 0x71, 0xa4,
		0x3d, 0xd4, 0x97, 0xf0, 0x1f, 0x17, 0xc0, 0xe2,
		0xcb, 0x37, 0x97, 0xaa, 0x2a, 0x2f, 0x25, 0x66,
		0x56, 0x16, 0x8e, 0x6c, 0x49, 0x6a, 0xfc, 0x5f,
		0xb9, 0x32, 0x46, 0xf6, 0xb1, 0x11, 0x63, 0x98,
		0xa3, 0x46, 0xf1, 0xa6, 0x41, 0xf3, 0xb0, 0x41,
		0xe9, 0x89, 0xf7, 0x91, 0x4f, 0x90, 0xcc, 0x2c,
		0x7f, 0xff, 0x35, 0x78, 0x76, 0xe5, 0x06, 0xb5,
		0x0d, 0x33, 0x4b, 0xa7, 0x7c, 0x22, 0x5b, 0xc3,
		0x07, 0xba, 0x53, 0x71, 0x52, 0xf3, 0xf1, 0x61,
		0x0e, 0x4e, 0xaf, 0xe5, 0x95, 0xf6, 0xd9, 0xd9,
		0x0d, 0x11, 0xfa, 0xa9, 0x33, 0xa1, 0x5e, 0xf1,
		0x36, 0x95, 0x46, 0x86, 0x8a, 0x7f, 0x3a, 0x45,
		0xa9, 0x67, 0x68, 0xd4, 0x0f, 0xd9, 0xd0, 0x34,
		0x12, 0xc0, 0x91, 0xc6, 0x31, 0x5c, 0xf4, 0xfd,
		0xe7, 0xcb, 0x68, 0x60, 0x69, 0x37, 0x38, 0x0d,
		0xb2, 0xea, 0xaa, 0x70, 0x7b, 0x4c, 0x41, 0x85,
		0xc3, 0x2e, 0xdd, 0xcd, 0xd3, 0x06, 0x70, 0x5e,
		0x4d, 0xc1, 0xff, 0xc8, 0x72, 0xee, 0xee, 0x47,
		0x5a, 0x64, 0xdf, 0xac, 0x86, 0xab, 0xa4, 0x1c,
		0x06, 0x18, 0x98, 0x3f, 0x87, 0x41, 0xc5, 0xef,
		0x68, 0xd3, 0xa1, 0x01, 0xe8, 0xa3, 0xb8, 0xca,
		0xc6, 0x0c, 0x90, 0x5c, 0x15, 0xfc, 0x91, 0x08,
		0x40, 0xb9, 0x4c, 0x00, 0xa0, 0xb9, 0xd0,
	];

	let signature = [
		0x0a, 0xab, 0x4c, 0x90, 0x05, 0x01, 0xb3, 0xe2,
		0x4d, 0x7c, 0xdf, 0x46, 0x63, 0x32, 0x6a, 0x3a,
		0x87, 0xdf, 0x5e, 0x48, 0x43, 0xb2, 0xcb, 0xdb,
		0x67, 0xcb, 0xf6, 0xe4, 0x60, 0xfe, 0xc3, 0x50,
		0xaa, 0x53, 0x71, 0xb1, 0x50, 0x8f, 0x9f, 0x45,
		0x28, 0xec, 0xea, 0x23, 0xc4, 0x36, 0xd9, 0x4b,
		0x5e, 0x8f, 0xcd, 0x4f, 0x68, 0x1e, 0x30, 0xa6,
		0xac, 0x00, 0xa9, 0x70, 0x4a, 0x18, 0x8a, 0x03,
	];

	assert_eq!(ed25519_sign(priv_key, message), signature);

	assert!(ed25519_verify(pub_key, message, signature));
}

#[test]
fn ed25519_test_vector_sha_abc() {
	let priv_key = [
		0x83, 0x3f, 0xe6, 0x24, 0x09, 0x23, 0x7b, 0x9d,
		0x62, 0xec, 0x77, 0x58, 0x75, 0x20, 0x91, 0x1e,
		0x9a, 0x75, 0x9c, 0xec, 0x1d, 0x19, 0x75, 0x5b,
		0x7d, 0xa9, 0x01, 0xb9, 0x6d, 0xca, 0x3d, 0x42,
	];

	let pub_key = [
		0xec, 0x17, 0x2b, 0x93, 0xad, 0x5e, 0x56, 0x3b,
		0xf4, 0x93, 0x2c, 0x70, 0xe1, 0x24, 0x50, 0x34,
		0xc3, 0x54, 0x67, 0xef, 0x2e, 0xfd, 0x4d, 0x64,
		0xeb, 0xf8, 0x19, 0x68, 0x34, 0x67, 0xe2, 0xbf,
	];

	assert_eq!(ed25519_derive_pub_key(priv_key), pub_key);

	let message = &[
		0xdd, 0xaf, 0x35, 0xa1, 0x93, 0x61, 0x7a, 0xba,
		0xcc, 0x41, 0x73, 0x49, 0xae, 0x20, 0x41, 0x31,
		0x12, 0xe6, 0xfa, 0x4e, 0x89, 0xa9, 0x7e, 0xa2,
		0x0a, 0x9e, 0xee, 0xe6, 0x4b, 0x55, 0xd3, 0x9a,
		0x21, 0x92, 0x99, 0x2a, 0x27, 0x4f, 0xc1, 0xa8,
		0x36, 0xba, 0x3c, 0x23, 0xa3, 0xfe, 0xeb, 0xbd,
		0x45, 0x4d, 0x44, 0x23, 0x64, 0x3c, 0xe8, 0x0e,
		0x2a, 0x9a, 0xc9, 0x4f, 0xa5, 0x4c, 0xa4, 0x9f,
	];

	let signature = [
		0xdc, 0x2a, 0x44, 0x59, 0xe7, 0x36, 0x96, 0x33,
		0xa5, 0x2b, 0x1b, 0xf2, 0x77, 0x83, 0x9a, 0x00,
		0x20, 0x10, 0x09, 0xa3, 0xef, 0xbf, 0x3e, 0xcb,
		0x69, 0xbe, 0xa2, 0x18, 0x6c, 0x26, 0xb5, 0x89,
		0x09, 0x35, 0x1f, 0xc9, 0xac, 0x90, 0xb3, 0xec,
		0xfd, 0xfb, 0xc7, 0xc6, 0x64, 0x31, 0xe0, 0x30,
		0x3d, 0xca, 0x17, 0x9c, 0x13, 0x8a, 0xc1, 0x7a,
		0xd9, 0xbe, 0xf1, 0x17, 0x73, 0x31, 0xa7, 0x04,
	];

	assert_eq!(ed25519_sign(priv_key, message), signature);

	assert!(ed25519_verify(pub_key, message, signature));
}

#[test]
fn ed25519ctx_test_vector_foo() {
	let priv_key = [
		0x03, 0x05, 0x33, 0x4e, 0x38, 0x1a, 0xf7, 0x8f,
		0x14, 0x1c, 0xb6, 0x66, 0xf6, 0x19, 0x9f, 0x57,
		0xbc, 0x34, 0x95, 0x33, 0x5a, 0x25, 0x6a, 0x95,
		0xbd, 0x2a, 0x55, 0xbf, 0x54, 0x66, 0x63, 0xf6,
	];

	let pub_key = [
		0xdf, 0xc9, 0x42, 0x5e, 0x4f, 0x96, 0x8f, 0x7f,
		0x0c, 0x29, 0xf0, 0x25, 0x9c, 0xf5, 0xf9, 0xae,
		0xd6, 0x85, 0x1c, 0x2b, 0xb4, 0xad, 0x8b, 0xfb,
		0x86, 0x0c, 0xfe, 0xe0, 0xab, 0x24, 0x82, 0x92,
	];

	assert_eq!(ed25519_derive_pub_key(priv_key), pub_key);

	let message = &[
		0xf7, 0x26, 0x93, 0x6d, 0x19, 0xc8, 0x00, 0x49,
		0x4e, 0x3f, 0xda, 0xff, 0x20, 0xb2, 0x76, 0xa8,
	];

	let context = &[0x66, 0x6f, 0x6f];

	let signature = [
		0x55, 0xa4, 0xcc, 0x2f, 0x70, 0xa5, 0x4e, 0x04,
		0x28, 0x8c, 0x5f, 0x4c, 0xd1, 0xe4, 0x5a, 0x7b,
		0xb5, 0x20, 0xb3, 0x62, 0x92, 0x91, 0x18, 0x76,
		0xca, 0xda, 0x73, 0x23, 0x19, 0x8d, 0xd8, 0x7a,
		0x8b, 0x36, 0x95, 0x0b, 0x95, 0x13, 0x00, 0x22,
		0x90, 0x7a, 0x7f, 0xb7, 0xc4, 0xe9, 0xb2, 0xd5,
		0xf6, 0xcc, 0xa6, 0x85, 0xa5, 0x87, 0xb4, 0xb2,
		0x1f, 0x4b, 0x88, 0x8e, 0x4e, 0x7e, 0xdb, 0x0d,
	];

	assert_eq!(ed25519ctx_sign(priv_key, message, context), signature);

	assert!(ed25519ctx_verify(pub_key, message, context, signature));
}

#[test]
fn ed25519ctx_test_vector_bar() {
	let priv_key = [
		0x03, 0x05, 0x33, 0x4e, 0x38, 0x1a, 0xf7, 0x8f,
		0x14, 0x1c, 0xb6, 0x66, 0xf6, 0x19, 0x9f, 0x57,
		0xbc, 0x34, 0x95, 0x33, 0x5a, 0x25, 0x6a, 0x95,
		0xbd, 0x2a, 0x55, 0xbf, 0x54, 0x66, 0x63, 0xf6,
	];

	let pub_key = [
		0xdf, 0xc9, 0x42, 0x5e, 0x4f, 0x96, 0x8f, 0x7f,
		0x0c, 0x29, 0xf0, 0x25, 0x9c, 0xf5, 0xf9, 0xae,
		0xd6, 0x85, 0x1c, 0x2b, 0xb4, 0xad, 0x8b, 0xfb,
		0x86, 0x0c, 0xfe, 0xe0, 0xab, 0x24, 0x82, 0x92,
	];

	assert_eq!(ed25519_derive_pub_key(priv_key), pub_key);

	let message = &[
		0xf7, 0x26, 0x93, 0x6d, 0x19, 0xc8, 0x00, 0x49,
		0x4e, 0x3f, 0xda, 0xff, 0x20, 0xb2, 0x76, 0xa8,
	];

	let context = &[0x62, 0x61, 0x72];

	let signature = [
		0xfc, 0x60, 0xd5, 0x87, 0x2f, 0xc4, 0x6b, 0x3a,
		0xa6, 0x9f, 0x8b, 0x5b, 0x43, 0x51, 0xd5, 0x80,
		0x8f, 0x92, 0xbc, 0xc0, 0x44, 0x60, 0x6d, 0xb0,
		0x97, 0xab, 0xab, 0x6d, 0xbc, 0xb1, 0xae, 0xe3,
		0x21, 0x6c, 0x48, 0xe8, 0xb3, 0xb6, 0x64, 0x31,
		0xb5, 0xb1, 0x86, 0xd1, 0xd2, 0x8f, 0x8e, 0xe1,
		0x5a, 0x5c, 0xa2, 0xdf, 0x66, 0x68, 0x34, 0x62,
		0x91, 0xc2, 0x04, 0x3d, 0x4e, 0xb3, 0xe9, 0x0d,
	];

	assert_eq!(ed25519ctx_sign(priv_key, message, context), signature);

	assert!(ed25519ctx_verify(pub_key, message, context, signature));
}

#[test]
fn ed25519ctx_test_vector_foo2() {
	let priv_key = [
		0x03, 0x05, 0x33, 0x4e, 0x38, 0x1a, 0xf7, 0x8f,
		0x14, 0x1c, 0xb6, 0x66, 0xf6, 0x19, 0x9f, 0x57,
		0xbc, 0x34, 0x95, 0x33, 0x5a, 0x25, 0x6a, 0x95,
		0xbd, 0x2a, 0x55, 0xbf, 0x54, 0x66, 0x63, 0xf6,
	];

	let pub_key = [
		0xdf, 0xc9, 0x42, 0x5e, 0x4f, 0x96, 0x8f, 0x7f,
		0x0c, 0x29, 0xf0, 0x25, 0x9c, 0xf5, 0xf9, 0xae,
		0xd6, 0x85, 0x1c, 0x2b, 0xb4, 0xad, 0x8b, 0xfb,
		0x86, 0x0c, 0xfe, 0xe0, 0xab, 0x24, 0x82, 0x92,
	];

	assert_eq!(ed25519_derive_pub_key(priv_key), pub_key);

	let message = &[
		0x50, 0x8e, 0x9e, 0x68, 0x82, 0xb9, 0x79, 0xfe,
		0xa9, 0x00, 0xf6, 0x2a, 0xdc, 0xea, 0xca, 0x35,
	];

	let context = &[0x66, 0x6f, 0x6f];

	let signature = [
		0x8b, 0x70, 0xc1, 0xcc, 0x83, 0x10, 0xe1, 0xde,
		0x20, 0xac, 0x53, 0xce, 0x28, 0xae, 0x6e, 0x72,
		0x07, 0xf3, 0x3c, 0x32, 0x95, 0xe0, 0x3b, 0xb5,
		0xc0, 0x73, 0x2a, 0x1d, 0x20, 0xdc, 0x64, 0x90,
		0x89, 0x22, 0xa8, 0xb0, 0x52, 0xcf, 0x99, 0xb7,
		0xc4, 0xfe, 0x10, 0x7a, 0x5a, 0xbb, 0x5b, 0x2c,
		0x40, 0x85, 0xae, 0x75, 0x89, 0x0d, 0x02, 0xdf,
		0x26, 0x26, 0x9d, 0x89, 0x45, 0xf8, 0x4b, 0x0b,
	];

	assert_eq!(ed25519ctx_sign(priv_key, message, context), signature);

	assert!(ed25519ctx_verify(pub_key, message, context, signature));
}

#[test]
fn ed25519ctx_test_vector_foo3() {
	let priv_key = [
		0xab, 0x9c, 0x28, 0x53, 0xce, 0x29, 0x7d, 0xda,
		0xb8, 0x5c, 0x99, 0x3b, 0x3a, 0xe1, 0x4b, 0xca,
		0xd3, 0x9b, 0x2c, 0x68, 0x2b, 0xea, 0xbc, 0x27,
		0xd6, 0xd4, 0xeb, 0x20, 0x71, 0x1d, 0x65, 0x60,
	];

	let pub_key = [
		0x0f, 0x1d, 0x12, 0x74, 0x94, 0x3b, 0x91, 0x41,
		0x58, 0x89, 0x15, 0x2e, 0x89, 0x3d, 0x80, 0xe9,
		0x32, 0x75, 0xa1, 0xfc, 0x0b, 0x65, 0xfd, 0x71,
		0xb4, 0xb0, 0xdd, 0xa1, 0x0a, 0xd7, 0xd7, 0x72,
	];

	assert_eq!(ed25519_derive_pub_key(priv_key), pub_key);

	let message = &[
		0xf7, 0x26, 0x93, 0x6d, 0x19, 0xc8, 0x00, 0x49,
		0x4e, 0x3f, 0xda, 0xff, 0x20, 0xb2, 0x76, 0xa8,
	];

	let context = &[0x66, 0x6f, 0x6f];

	let signature = [
		0x21, 0x65, 0x5b, 0x5f, 0x1a, 0xa9, 0x65, 0x99,
		0x6b, 0x3f, 0x97, 0xb3, 0xc8, 0x49, 0xea, 0xfb,
		0xa9, 0x22, 0xa0, 0xa6, 0x29, 0x92, 0xf7, 0x3b,
		0x3d, 0x1b, 0x73, 0x10, 0x6a, 0x84, 0xad, 0x85,
		0xe9, 0xb8, 0x6a, 0x7b, 0x60, 0x05, 0xea, 0x86,
		0x83, 0x37, 0xff, 0x2d, 0x20, 0xa7, 0xf5, 0xfb,
		0xd4, 0xcd, 0x10, 0xb0, 0xbe, 0x49, 0xa6, 0x8d,
		0xa2, 0xb2, 0xe0, 0xdc, 0x0a, 0xd8, 0x96, 0x0f,
	];

	assert_eq!(ed25519ctx_sign(priv_key, message, context), signature);

	assert!(ed25519ctx_verify(pub_key, message, context, signature));
}

#[test]
fn ed25519ph_test_vector_abc() {
	let priv_key = [
		0x83, 0x3f, 0xe6, 0x24, 0x09, 0x23, 0x7b, 0x9d,
		0x62, 0xec, 0x77, 0x58, 0x75, 0x20, 0x91, 0x1e,
		0x9a, 0x75, 0x9c, 0xec, 0x1d, 0x19, 0x75, 0x5b,
		0x7d, 0xa9, 0x01, 0xb9, 0x6d, 0xca, 0x3d, 0x42,
	];

	let pub_key = [
		0xec, 0x17, 0x2b, 0x93, 0xad, 0x5e, 0x56, 0x3b,
		0xf4, 0x93, 0x2c, 0x70, 0xe1, 0x24, 0x50, 0x34,
		0xc3, 0x54, 0x67, 0xef, 0x2e, 0xfd, 0x4d, 0x64,
		0xeb, 0xf8, 0x19, 0x68, 0x34, 0x67, 0xe2, 0xbf,
	];

	assert_eq!(ed25519_derive_pub_key(priv_key), pub_key);

	let message = &[0x61, 0x62, 0x63];
	let context = &[];

	let signature = [
		0x98, 0xa7, 0x02, 0x22, 0xf0, 0xb8, 0x12, 0x1a,
		0xa9, 0xd3, 0x0f, 0x81, 0x3d, 0x68, 0x3f, 0x80,
		0x9e, 0x46, 0x2b, 0x46, 0x9c, 0x7f, 0xf8, 0x76,
		0x39, 0x49, 0x9b, 0xb9, 0x4e, 0x6d, 0xae, 0x41,
		0x31, 0xf8, 0x50, 0x42, 0x46, 0x3c, 0x2a, 0x35,
		0x5a, 0x20, 0x03, 0xd0, 0x62, 0xad, 0xf5, 0xaa,
		0xa1, 0x0b, 0x8c, 0x61, 0xe6, 0x36, 0x06, 0x2a,
		0xaa, 0xd1, 0x1c, 0x2a, 0x26, 0x08, 0x34, 0x06,
	];

	assert_eq!(ed25519ph_sign(priv_key, message, context), signature);

	assert!(ed25519ph_verify(pub_key, message, context, signature));
}
